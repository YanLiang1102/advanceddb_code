//******************************************************************************
// Copyright (C) 2016 University of Oklahoma Board of Trustees.
//******************************************************************************
// Last modified: Tue Feb  9 20:33:16 2016 by Chris Weaver
//******************************************************************************
// Major Modification History:
//
// 20160209 [weaver]:	Original file.
//
//******************************************************************************
// Notes:
//
//******************************************************************************

package edu.ou.cs.cg.homework;

//import java.lang.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import java.util.Random;
import javax.swing.*;
import javax.media.opengl.*;
import javax.media.opengl.awt.GLCanvas;
import javax.media.opengl.glu.*;
import com.jogamp.opengl.util.*;
import com.jogamp.opengl.util.awt.TextRenderer;
import com.jogamp.opengl.util.gl2.GLUT;

//******************************************************************************

/**
 * The <CODE>Homework02</CODE> class.<P>
 *
 * @author  Chris Weaver
 * @version %I%, %G%
 */
public final class Homework02
	implements GLEventListener
{
	//**********************************************************************
	// Public Class Members
	//**********************************************************************

	public static final GLU		GLU = new GLU();
	public static final GLUT	GLUT = new GLUT();
	public static final Random	RANDOM = new Random();

	//**********************************************************************
	// Private Members
	//**********************************************************************

	// State (internal) variables
	private int				k = 0;		// Just an animation counter

	private int				w;			// Canvas width
	private int				h;			// Canvas height
	private TextRenderer	renderer;

	public interface Transform<T> {



	/**

	 * Transforms and returns the transformation of the parameter val.

	 * @param val The object to transform

	 * @return The transformed object. Whether the returned value is the same or a different

	 *  	instance than val is implementation specific.

	 */

	public T transform(T val);

}



/**

 * Class to store 3-dimensional values. 

 * @author G Cope

 *

 */

public class Tuple3d{

	

	public final double x;

	public final double y;

	public final double z;



	/**

	 * Constructs a new Tuple class. 

	 * @param x

	 * @param y

	 * @param z

	 */

	public Tuple3d(double x, double y, double z){

		this.x = x;

		this.y = y;

		this.z = z;

	}

	

	@Override

	public String toString(){

		return "[" + x + ":" + y + ":" + z + "]";

	}

}



/**

 * Attractor based upon the Lorenz equations

 * @author G Cope

 *

 */

public class Lorenz{



	private Tuple3d current = new Tuple3d(0,0,0);

	

	private double a = 10d;

	private double b = 8/3d;

	private double c = 28d;

	

	private double dt = 0.1;


	// private double a = 0.0d;

	// private double b = 0.0d;

	// private double c = 0.0d;

	

	// private double dt = 0.01;

	

	

	/*

	 * The Lorenz equations implemented as a Transform of a Tuple

	 */

	private Transform<Tuple3d> transform = new Transform<Tuple3d>(){



		@Override

		public Tuple3d transform(Tuple3d val) {

			double dxdt = a*(val.y - val.x);

			double dydt = (val.x * (c - val.z) - val.y);

			double dzdt = (val.x*val.y - b * val.z);

			double nx = val.x + dt * dxdt;

			double ny = val.y + dt * dydt;

			double nz = val.z + dt * dzdt ;

			return new Tuple3d(nx, ny, nz);

		}

		

	};



	

	//Cumulative time.

	private double time = 0;

	

	

	/**

	 * Construct a new object with an initial point at the origin and time change of 0.1

	 */

	public Lorenz(){

		this(0,0,0);

	}

	

	/**

	 * Construct a new object with an initial point and default time change of 0.1

	 * @param x

	 * @param y

	 * @param z

	 */

	public Lorenz(double x, double y, double z){

		this(x, y, z, 0.1);

	}

	

	/**

	 * Constructs a new object with an initial point and change in time

	 * @param x

	 * @param y

	 * @param z

	 * @param time

	 */

	public Lorenz(double x, double y, double z, double deltaTime){

		current = new Tuple3d(x, y, z);

		this.dt = deltaTime;

	}

	

	public void setTransform(Transform<Tuple3d> transform){

		this.transform = transform;

	}



	/**

	 * Gets the current cumulative time.

	 * @return

	 */

	public double getCurrentTime(){

		return time;

	}

	

	/**

	 * Sets the delta time parameter

	 * @param dt

	 */

	public void setDt(double dt){

		this.dt = dt;

	}

	

	



	/**

	 * Iterates one step forward in time.

	 */

	public void iterate(){

		time += dt;

		current = transform.transform(current); 

	}

	

	/**

	 * Retrieves the current location. 

	 * @return

	 */

	public Tuple3d getCurrentLocation(){

		return current;

	}

	

}


	//**********************************************************************
	// Main
	//**********************************************************************

	public static void main(String[] args)
	{
		GLProfile		profile = GLProfile.getDefault();
		GLCapabilities	capabilities = new GLCapabilities(profile);
		GLCanvas		canvas = new GLCanvas(capabilities);
		JFrame			frame = new JFrame("Homework02");

		canvas.setPreferredSize(new Dimension(1500,800));

		frame.setBounds(50, 50, 600, 600);
		frame.getContentPane().add(canvas);
		frame.pack();
		frame.setVisible(true);
		frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
       // frame.setBackground(Color.WHITE);
		frame.addWindowListener(new WindowAdapter() {
				public void windowClosing(WindowEvent e) {
					System.exit(0);
				}
			});

		canvas.addGLEventListener(new Homework02());
		//canvas.glClear();
		//canvas.setColor(0.0f,1.0f,0.0f,0.0F);

		//turn off the animation for now.
		//FPSAnimator		animator = new FPSAnimator(canvas, 60);

		//animator.start();
	}

	//**********************************************************************
	// Override Methods (GLEventListener)
	//**********************************************************************

	public void		init(GLAutoDrawable drawable)
	{
		w = drawable.getWidth();
		h = drawable.getHeight();
        
		renderer = new TextRenderer(new Font("Serif", Font.PLAIN, 18),
									true, true);
	}

	public void		dispose(GLAutoDrawable drawable)
	{
		renderer = null;
	}

	public void		display(GLAutoDrawable drawable)
	{
		update();
		render(drawable);
	}

	public void		reshape(GLAutoDrawable drawable, int x, int y, int w, int h)
	{
		this.w = w;
		this.h = h;
	}

	//**********************************************************************
	// Private Methods (Rendering)
	//**********************************************************************

	private void	update()
	{
		k++;									// Counters are useful, right?
	}

	private void	render(GLAutoDrawable drawable)
	{
		GL2		gl = drawable.getGL().getGL2();
        gl.glClearColor(0.573f, 0.573f, 0.573f, 1.0f);
		gl.glClear(GL.GL_COLOR_BUFFER_BIT);		// Clear the buffer

		//setProjection(gl);						// Use a coordinate system

		drawSomething(gl);						// Draw something
		drawSomeText(drawable);					// Draw some text
	}

	//**********************************************************************
	// Private Methods (Coordinate System)
	//**********************************************************************

	private void	setProjection(GL2 gl)
	{
		GLU		glu = new GLU();

		gl.glMatrixMode(GL2.GL_PROJECTION);			// Prepare for matrix xform
		gl.glLoadIdentity();						// Set to identity matrix
		glu.gluOrtho2D(-1.0f, 1.0f, -1.0f, 1.0f);	// 2D translate and scale
	}

	//**********************************************************************
	// Private Methods (Scene)
	//**********************************************************************

	// This page is helpful (scroll down to "Drawing Lines and Polygons"):
	// http://www.linuxfocus.org/English/January1998/article17.html
	private void	drawSomething(GL2 gl)
	{
		Lorenz lor=new Lorenz(0.1d,0.1d,0.1d);
		for(int i=0;i<=100;i++)
		{
			//need to get the next point
		lor.iterate();
		//the current 3d poirnt.
	    Tuple3d point=lor.getCurrentLocation();
	   // System.out.println("x value: "+i+" "+point.x);
	    //System.out.println("y value: "+i+" "+point.y);
	   // System.out.println("z value: "+i+" "+point.z);
	    gl.glBegin(GL.GL_POINTS);

		gl.glColor3f(0.0f, 0.0f, 0.0f);
		gl.glPointSize(2.0f);
		gl.glVertex3d(point.x,point.y,0.0d);
		gl.glEnd();

		}
        	float width=0.042f;
		  	float leftheight=0.3f;
		  	float rightheight=.35f;
		  	float start1=-0.98f;
		  	float offset1=0.01f;
		  	float housewidth=(float)(6.0*width);
		    float househeight=(float)(10.0*width);
		    float bound1=-0.8f;
		    float offset2=0.06f;

		gl.glBegin(GL.GL_POINTS);

		gl.glColor3f(1.0f, 1.0f, 1.0f);
		gl.glPointSize(2.0f);
		gl.glVertex2d(0.0, 0.0);
		gl.glEnd();
      
      //need to be changed with the campus width and  height
	  float ratio=(float)(1500.0f/800.0f);
      int numberOfLines=25;
      for(int i=0;i<=numberOfLines;i++)
      {
      	gl.glBegin(GL2.GL_LINES);
      	//need to do this cast in order to make this work.
      	float x1=(float)(-0.98f+(2.0/numberOfLines*i));
      	float x2=(float)(-0.98f+(2.0/numberOfLines*(i+0.65f)));
      	gl.glVertex2f(x1,-1.0f);
      	gl.glVertex2f(x2,-0.8f);
      	gl.glEnd();

      }
     
      //drawPolygon(gl,)

      //beginning of the drawing the gradient green
        gl.glBegin(GL2.GL_QUAD_STRIP);  

	    gl.glColor3f((float)(86.0/255.0),(float)(123.0/255.0),(float)(69.0/255.0));  
	    gl.glVertex2f(-1.0f,-0.8f);  
	    gl.glVertex2f(1.0f,-0.8f);  

	   gl.glColor3f((float)(82.0/255.0),(float)(102.0/255.0),(float)(65.0/255.0));  
	    gl.glVertex2f( -1.0f,bound1+offset1+0.5f*househeight);  
	    gl.glVertex2f( 1.0f, bound1+offset1+0.5f*househeight);  

	    gl.glColor3f((float)(76.0/255.0),(float)(60.0/255.0),(float)(49.0/255.0));  
	    gl.glVertex2f( -1.0f, bound1+offset2+househeight);  
	    gl.glVertex2f( 1.0f,bound1+offset2+househeight);  

	    gl.glEnd(); 
    //end of drawing the gradient green.
	    //start drawing the gradient sky
	     gl.glBegin(GL2.GL_QUAD_STRIP);  

	    gl.glColor3f((float)(125.0/255.0),(float)(106.0/255.0),(float)(74/255.0));  
	        gl.glVertex2f( -1.0f, bound1+offset2+househeight);  
	    gl.glVertex2f( 1.0f,bound1+offset2+househeight);   

	   gl.glColor3f((float)(54.0/255.0),(float)(54.0/255.0),(float)(56.0/255.0));  
	    gl.glVertex2f( -1.0f,0.5f+0.5f*bound1+offset1+0.5f*househeight);  
	    gl.glVertex2f( 1.0f, 0.f+0.5f*bound1+offset1+0.5f*househeight);  

	    gl.glColor3f((float)(17.0/255.0),(float)(21.0/255.0),(float)(32.0/255.0));  
	    gl.glVertex2f( -1.0f, 1.0f);  
	    gl.glVertex2f( 1.0f,1.0f);  

	    gl.glEnd(); 

	    //end of drawing the gradient sky
      //draw the line on the top and draw the line on the bottom, and if nothing has been set up the line is going to be look like white
      gl.glBegin(GL2.GL_LINES);
  	  gl.glVertex2f(-1.0f,-1.0f);
  	  gl.glVertex2f(1.0f,-1.0f);
  	  gl.glEnd();
      
  	  gl.glBegin(GL2.GL_LINES);
  	  gl.glVertex2f(-1.0f,bound1);
  	  gl.glVertex2f(1.0f,bound1);
  	  gl.glEnd();

  	   //the width of each grass will be :
     //only for these numbers I can only change:

      float grasswidth=(float)(2.0f/numberOfLines);
      float grassheight=(float)(0.05f);
      float grassstart=(float)(-0.99f+(2.0/numberOfLines*13));
      float grassheightstart=(float)(-1.0f)*(1.0f-2*grassheight);
       float grassdiff=(float)(2.0f/numberOfLines*0.65f)/0.2f*grassheight;
      //gl.glColor3f((float)(189.0/255.0),(float)(190.0/255.0),(float)(149.0/255.0)); 
      gl.glColor3f((float)(189.0/255.0),(float)(190.0/255.0),(float)(149.0/255.0));  
      draw3Polygon(gl,grassstart,grassheightstart,grassstart+grasswidth,grassheightstart,grassstart+grasswidth+grassdiff,grassheightstart+grassheight,grassdiff, grassheightstart, grasswidth, grassheight);
      //now need to draw the vertical two polygons together.
      //draw2Polygon(gl,)

  	  //seperate the width to be 11 sections
  	  int sections=11;



  	// float width=0.042f;
  	// float leftheight=0.3f;
  	// float rightheight=.35f;
  	// float start1=-0.98f;
  	// float offset1=0.01f;
  	// float housewidth=(float)(6.0*width);
   //  float househeight=(float)(10.0*width);
  	//float heightstart1=
  
    for(int i=0;i<4;i++)
    {
       gl.glColor3f((float)(192.0/255.0),(float)(187/255.0),(float)(126/255.0));   
    	drawPolygon(gl,(float)(start1+i*width
    		),bound1+offset1,leftheight,rightheight,width);
    	drawPolyBoundary(gl,(float)(start1+i*width
    		),bound1+offset1,leftheight,rightheight,width);
    }
    gl.glColor3f(1.0f,1.0f,1.0f);	
    
    //set up the first house , need to set the color white
    gl.glColor3f(1.0f,1.0f,1.0f);	
    float start2=(float)(start1+4*width+offset1);

    gl.glColor3f((float)(82/255.0),(float)(81.0/255.0),(float)(0.0/255.0));
    drawPolygon(gl,start2,bound1+offset1,househeight, househeight,housewidth);
    gl.glColor3f((float)(75.0/255.0),(float)(61.0/255.0),(float)(32.0/255.0));
    drawTriangle(gl,start2,bound1+offset1+househeight,housewidth,househeight*0.55f);
    //now set the color back to black
    gl.glColor3f(0.0f,0.0f,0.0f);
    //draw the line on the top of the house
    //there are altogethe
    float house1x=0.0f;
    float house1y=bound1+offset1+househeight;
    for(int i=0;i<=5;i++)
    {
    	house1x=(float)(start2+housewidth/5.0*i);
    	gl.glBegin(GL2.GL_LINES);
	  	gl.glVertex2f(house1x,house1y);
	  	gl.glVertex2f((float)(start2+housewidth/2.0),house1y+househeight*0.55f);
	  	  //gl.glColor3f(0.0f,0.0f,0.0f);
	  	gl.glEnd();

    }
    //now need to draw the door of the first house
     gl.glColor3f((float)(209.0/255.0),(float)(148.0/255.0),(float)(5.0/255.0));
     float startdoor1=(float)(start2+0.25f*housewidth);
     drawPolygon(gl,startdoor1,bound1+offset1,(float)(0.6*househeight),(float)(0.6*househeight),(float)(0.22*housewidth));
     //need to draw the handle on teh door
     gl.glColor3f(1.0f,1.0f,1.0f);
     drawFilledCircle(gl,startdoor1+0.05f*housewidth,bound1+offset1+0.3f*househeight,0.03f*housewidth,ratio,20);
    //ok now the first house is done, need to draw another two fences.
     //now need to draw the bound of the circle
     gl.glColor3f(0.0f,0.0f,0.0f);
     drawHollowCircle(gl,startdoor1+0.05f*housewidth,bound1+offset1+0.3f*househeight,0.03f*housewidth,ratio);

     //need to draw the chimney on top of the house
     //find the triangle the top vertex and the right vertex
     float topx=(float)(start2+0.5f*housewidth);
     //adds in the triangle height too.
     float topy=(float)(bound1+offset1+househeight*1.55f);
     float rightx=(float)(start2+housewidth);
     float righty=(float)(bound1+offset1+househeight);

     //the first x on the triangle will be 
     float chimx1=(float)(topx+(rightx-topx)*0.3333f);
     float chimx2=(float)(topx+(rightx-topx)*0.6666f);
     float chimy1=findYonTheLine(topx,topy,rightx,righty,chimx1);
     float chimy2=findYonTheLine(topx,topy,rightx,righty,chimx2);

     float topchimx1=chimx1;
     float topchimy1=topy;

     float chim1leftlength=findDistanceTwoPoints(topchimx1,topchimy1,chimx1,chimy1);
     float rightlengthOfTriangle=findDistanceTwoPoints(topx,topy,rightx,righty);
     float bottomlengthOfchimney=findDistanceTwoPoints(chimx1,chimy1,chimx2,chimy2);
     float chimrightlength=chim1leftlength+(float)((bottomlengthOfchimney/rightlengthOfTriangle)*househeight*0.55f);
     float chimneywidth=(float)((bottomlengthOfchimney/rightlengthOfTriangle)*0.5f*housewidth);
     gl.glColor3f((float)(153.0/255.0),(float)(15.0/255.0),(float)(0/255.0));
     //the trick here is that I can set the leftheight and rigfht height to be negative.
     drawPolygon(gl,topchimx1,topchimy1,-1.0f*chim1leftlength,-1.0f*chimrightlength,chimneywidth);
     //draw the boundary of the polygon
     gl.glColor3f(0.0f,0.0f,0.0f);
     drawPolyBoundary(gl,topchimx1,topchimy1,-1.0f*chim1leftlength,-1.0f*chimrightlength,chimneywidth);

     //now need to draw the smoke on top of the chimney.
     //ok the chimney is the hard part to drwa since u can not direcly draw it, the whole thing is not convex.
     float s1=topchimx1+0.1f*chimneywidth;
     float s2=topchimy1;
     float s3=s1;
     float s4=s2+0.7f*chimneywidth;
     float s27=s1+0.8f*chimneywidth;
     float s28=s2;
     float s25=s27;
     float s26=s4+0.2f*chimneywidth;
     float s5=s3+0.2f*chimneywidth;
     float s6=s4+0.2f*chimneywidth;
     float s7=s5+0.1f*chimneywidth;
     float s8=s6+chimneywidth;
     float s23=s25+0.2f*chimneywidth;
     float s24=s26+0.4f*chimneywidth;
     float s21=s23-0.3f*chimneywidth;
     float s22=s24+0.6f*chimneywidth;
     float s9=s7-0.2f*chimneywidth;
     float s10=s8+0.35f*chimneywidth;
     float s19=s21+0.1f*chimneywidth;
     float s20=s22+0.35f*chimneywidth;
     float s11=s1+0.6f*chimneywidth;
     float s12=s10+1.8f*chimneywidth;
     float s17=s19;
     float s18=s20+0.5f*chimneywidth;
     float s15=s17+0.1f*chimneywidth;
     float s16=s18+0.8f*chimneywidth;
     float s13=s11+0.2f*chimneywidth;
     float s14=s12;

     gl.glColor3f((float)(174.0/255.0),(float)(173/255.0),(float)(169/255.0));
     gl.glBegin(GL2.GL_POLYGON);
  	    gl.glVertex2f(s1,s2);
  	    gl.glVertex2f(s27,s28);
  	    gl.glVertex2f(s25,s26);
  	    gl.glVertex2f(s3,s4);
  	    gl.glEnd();

  	    gl.glBegin(GL2.GL_POLYGON);
  	    gl.glVertex2f(s3,s4);
  	    gl.glVertex2f(s25,s26);
  	    gl.glVertex2f(s5,s6);
  	    gl.glEnd();

  	      gl.glBegin(GL2.GL_POLYGON);
  	    gl.glVertex2f(s5,s6);
  	    gl.glVertex2f(s25,s26);
  	    gl.glVertex2f(s23,s24);
  	     gl.glVertex2f(s7,s8);
  	    gl.glEnd();

  	      gl.glBegin(GL2.GL_POLYGON);
  	    gl.glVertex2f(s7,s8);
  	    gl.glVertex2f(s23,s24);
  	    gl.glVertex2f(s21,s22);
  	    gl.glEnd();

  	        gl.glBegin(GL2.GL_POLYGON);
  	    gl.glVertex2f(s7,s8);
  	    gl.glVertex2f(s21,s22);
  	    gl.glVertex2f(s19,s20);
  	     gl.glVertex2f(s9,s10);
  	    gl.glEnd();

  	         gl.glBegin(GL2.GL_POLYGON);
  	    gl.glVertex2f(s9,s10);
  	    gl.glVertex2f(s19,s20);
  	    gl.glVertex2f(s17,s18);
  	    gl.glEnd();

  	         gl.glBegin(GL2.GL_POLYGON);
  	    gl.glVertex2f(s9,s10);
  	    gl.glVertex2f(s17,s18);
  	    gl.glVertex2f(s11,s12);
  	    gl.glEnd();

  	    gl.glBegin(GL2.GL_POLYGON);
  	    gl.glVertex2f(s11,s12);
  	    gl.glVertex2f(s17,s18);
  	    gl.glVertex2f(s15,s16);
  	     gl.glVertex2f(s13,s14);
  	    gl.glEnd();

  	    //now need to draw window here
  	    drawWindow(gl,startdoor1+0.45f*housewidth,bound1+offset1+(float)(0.6*househeight),(float)(0.30f*housewidth),(float)(0.15f*housewidth));
        

    float start3=(float)(start2+offset1+housewidth);
       for(int i=0;i<4;i++)
    {
         gl.glColor3f((float)(192.0/255.0),(float)(187/255.0),(float)(126/255.0));
    	drawPolygon(gl,(float)(start3+i*width
    		),bound1+offset1,leftheight,rightheight,width);
    	drawPolyBoundary(gl,(float)(start3+i*width
    		),bound1+offset1,leftheight,rightheight,width);
    }
     
     //the diff now is the width of the fence instead of width of the house.
      float start4=(float)(start3+offset1+4*width);
       for(int i=0;i<4;i++)
    {
          gl.glColor3f((float)(192.0/255.0),(float)(187/255.0),(float)(126/255.0));
    	drawPolygon(gl,(float)(start4+i*width
    		),bound1+offset1,leftheight,rightheight,width);
    	drawPolyBoundary(gl,(float)(start4+i*width
    		),bound1+offset1,leftheight,rightheight,width);
    }

    //draw the house2 in the middle
    float start5=start4+8*width+offset1;
    //the second house is little bit upper, so
    
    //set the color back;
    gl.glColor3f((float)(129.0/255.0),(float)(61/255.0),(float)(0/255.0));
    drawPolygon(gl,start5,bound1+offset2,househeight, househeight,housewidth);
    //draw the triangle on the top of the house
    drawTriangle(gl,start5,bound1+offset2+househeight,housewidth,0.55f*househeight);
      drawStar(gl,start5+0.5f*housewidth,bound1+offset2+househeight+0.275f*househeight,0.01f,0.02f,ratio,5);

    //now need to draw the door on the house
     gl.glColor3f((float)(209.0/255.0),(float)(148.0/255.0),(float)(5.0/255.0));
     float startdoor2=(float)(start5+0.05f*housewidth);
     drawPolygon(gl,startdoor2,bound1+offset2,(float)(0.6*househeight),(float)(0.6*househeight),(float)(0.22*housewidth));
     //need to draw the handle on teh door
     gl.glColor3f(1.0f,1.0f,1.0f);
     drawFilledCircle(gl,startdoor2+0.05f*housewidth,bound1+offset2+0.3f*househeight,0.03f*housewidth,ratio,20);
    //ok now the first house is done, need to draw another two fences.
     //now need to draw the bound of the circle
     gl.glColor3f(0.0f,0.0f,0.0f);
     drawHollowCircle(gl,startdoor2+0.05f*housewidth,bound1+offset2+0.3f*househeight,0.03f*housewidth,ratio);
     //the end of drawing the door on the second house.

     //draw the window on the door
     drawWindow(gl,startdoor2+0.45f*housewidth,bound1+offset2+(float)(0.4*househeight),(float)(0.20f*househeight),(float)(0.15f*housewidth));
     //end of drawing two windows on the door
     //now need to draw the second window here
     drawWindow(gl,startdoor2+0.50f*housewidth+0.15f*housewidth,bound1+offset2+(float)(0.4*househeight),(float)(0.20f*househeight),(float)(0.15f*housewidth));
     //now need the chimney for the house2
     //beginning of the chimney
      topx=(float)(start5+0.5f*housewidth);
     //adds in the triangle height too.
      topy=(float)(bound1+offset2+househeight*1.55f);
      rightx=start5;//(float)(start2+housewidth);
      righty=(float)(bound1+offset2+househeight);

     //the first x on the triangle will be 
      chimx1=(float)(topx+(rightx-topx)*0.3333f);
      chimx2=(float)(topx+(rightx-topx)*0.6666f);
      chimy1=findYonTheLine(topx,topy,rightx,righty,chimx1);
      chimy2=findYonTheLine(topx,topy,rightx,righty,chimx2);

      topchimx1=chimx1;
      topchimy1=topy;

      chim1leftlength=findDistanceTwoPoints(topchimx1,topchimy1,chimx1,chimy1);
      rightlengthOfTriangle=findDistanceTwoPoints(topx,topy,rightx,righty);
      bottomlengthOfchimney=findDistanceTwoPoints(chimx1,chimy1,chimx2,chimy2);
     chimrightlength=chim1leftlength+(float)((bottomlengthOfchimney/rightlengthOfTriangle)*househeight*0.55f);
      chimneywidth=(float)((bottomlengthOfchimney/rightlengthOfTriangle)*0.5f*housewidth);
     gl.glColor3f((float)(153.0/255.0),(float)(15.0/255.0),(float)(0/255.0));
     //the trick here is that I can set the leftheight and rigfht height to be negative.
     drawPolygon(gl,topchimx1,topchimy1,-1.0f*chim1leftlength,-1.0f*chimrightlength,-1.0f*chimneywidth);
     //draw the boundary of the polygon
     gl.glColor3f(0.0f,0.0f,0.0f);
     drawPolyBoundary(gl,topchimx1,topchimy1,-1.0f*chim1leftlength,-1.0f*chimrightlength,-1.0f*chimneywidth);
     //end of the chimney


    //set the color back
    gl.glColor3f(1.0f,1.0f,1.0f);

    //now need to draw 8 pieces of fences
     float start6=(float)(start5+width+housewidth);
       for(int i=1;i<=8;i++)
    {
          gl.glColor3f((float)(192.0/255.0),(float)(187/255.0),(float)(126/255.0));
        if(i%2==0)
        {
        	//if i is even, then the rigfht height is less than the left height.
        	drawPolygon(gl,(float)(start6+i*width
    		),bound1+offset1,rightheight,leftheight,width);
    	drawPolyBoundary(gl,(float)(start6+i*width
    		),bound1+offset1,rightheight,leftheight,width);

        	continue;
        }
    	drawPolygon(gl,(float)(start6+i*width
    		),bound1+offset1,leftheight,rightheight,width);
    	drawPolyBoundary(gl,(float)(start6+i*width
    		),bound1+offset1,leftheight,rightheight,width);
    }
    //need to draw the string on top the fence
    //show be the 8th one
    float string1x=start6+8*width;
    float string1y=bound1+offset1+rightheight;
    gl.glColor3f(1.0f,1.0f,1.0f);

    float string2x=string1x-1.5f*width;
    float string2y=string1y+1.5f*width;

     gl.glBegin(GL2.GL_LINES);
  	  gl.glVertex2f(string1x,string1y);
  	  gl.glVertex2f(string2x,string2y);
  	  gl.glEnd();

  	float string3x=string2x-width;
  	float string3y=string2y+2.8f*width;
  	  gl.glBegin(GL2.GL_LINES);
  	  gl.glVertex2f(string2x,string2y);
  	  gl.glVertex2f(string3x,string3y);
  	  gl.glEnd();

  	float string4x=string3x;
  	float string4y=string3y+2.8f*width;
  	gl.glBegin(GL2.GL_LINES);
  	  gl.glVertex2f(string4x,string4y);
  	  gl.glVertex2f(string3x,string3y);
  	  gl.glEnd();

  	float string5x=string4x-2.0f*width;
  	float string5y=string4y+2.8f*width;
	gl.glBegin(GL2.GL_LINES);
  	  gl.glVertex2f(string4x,string4y);
  	  gl.glVertex2f(string5x,string5y);
  	  gl.glEnd();

  	  	float string6x=string5x+0.5f*width;
  	float string6y=string5y+2.8f*width;
  	gl.glBegin(GL2.GL_LINES);
  	  gl.glVertex2f(string6x,string6y);
  	  gl.glVertex2f(string5x,string5y);
  	  gl.glEnd();

  	float string7x=string6x+0.3f*width;
  	float string7y=string6y+1.2f*width;
  	gl.glBegin(GL2.GL_LINES);
  	  gl.glVertex2f(string6x,string6y);
  	  gl.glVertex2f(string7x,string7y);
  	  gl.glEnd();

  	float string8x=0.5f;
  	float string8y=0.4f;
  	gl.glBegin(GL2.GL_LINES);
  	  gl.glVertex2f(string8x,string8y);
  	  gl.glVertex2f(string7x,string7y);
  	  gl.glEnd();











    //now need to draw the last house3, the last house is right adjacent to the fence
	
    float start7=start6+9*width;
    gl.glColor3f((float)(129.0/255.0),(float)(61/255.0),(float)(0/255.0));
    drawPolygon(gl,start7,bound1+offset1,househeight, househeight,housewidth);
         //draw chimney
    topx=(float)(start7+0.5f*housewidth);
     //adds in the triangle height too.
      topy=(float)(bound1+offset1+househeight*1.55f);
      rightx=start7;//(float)(start2+housewidth);
      righty=(float)(bound1+offset1+househeight);

     //the first x on the triangle will be 
      chimx1=(float)(topx+(rightx-topx)*0.3333f);
      chimx2=(float)(topx+(rightx-topx)*0.6666f);
      chimy1=findYonTheLine(topx,topy,rightx,righty,chimx1);
      chimy2=findYonTheLine(topx,topy,rightx,righty,chimx2);

      topchimx1=chimx1;
      topchimy1=topy;

      chim1leftlength=findDistanceTwoPoints(topchimx1,topchimy1,chimx1,chimy1);
      rightlengthOfTriangle=findDistanceTwoPoints(topx,topy,rightx,righty);
      bottomlengthOfchimney=findDistanceTwoPoints(chimx1,chimy1,chimx2,chimy2);
     chimrightlength=chim1leftlength+(float)((bottomlengthOfchimney/rightlengthOfTriangle)*househeight*0.55f);
      chimneywidth=(float)((bottomlengthOfchimney/rightlengthOfTriangle)*0.5f*housewidth);
     gl.glColor3f((float)(153.0/255.0),(float)(15.0/255.0),(float)(0/255.0));
     //the trick here is that I can set the leftheight and rigfht height to be negative.
     drawPolygon(gl,topchimx1,topchimy1,-1.0f*chim1leftlength,-1.0f*chimrightlength,-1.0f*chimneywidth);
     //draw the boundary of the polygon
     gl.glColor3f(0.0f,0.0f,0.0f);
     drawPolyBoundary(gl,topchimx1,topchimy1,-1.0f*chim1leftlength,-1.0f*chimrightlength,-1.0f*chimneywidth);
     

    //need to draw the triangle on the top of house.
    //drawPolygon(gl,start5,bound1+offset2,househeight, househeight,housewidth);
    //draw the triangle on the top of the house
    gl.glColor3f((float)(129.0/255.0),(float)(61/255.0),(float)(0/255.0));
    drawTriangle(gl,start7,bound1+offset1+househeight,housewidth,0.55f*househeight);
    //start drawig door and window for the last house, 
    gl.glColor3f((float)(209.0/255.0),(float)(148.0/255.0),(float)(5.0/255.0));
     float startdoor3=(float)(start7+0.05f*housewidth);
     drawPolygon(gl,startdoor3,bound1+offset1,(float)(0.6*househeight),(float)(0.6*househeight),(float)(0.22*housewidth));
     //need to draw the handle on teh door
     gl.glColor3f((float)(248.0/255.0),(float)(249/255.0),(float)(158/255.0));
     drawFilledCircle(gl,startdoor3+0.1f*housewidth,bound1+offset1+0.5f*househeight,0.05f*housewidth,ratio,20);
    //ok now the first house is done, need to draw another two fences.
     //now need to draw the bound of the circle
     //gl.glColor3f(0.0f,0.0f,0.0f);
     //drawHollowCircle(gl,startdoor3+0.05f*housewidth,bound1+offset1+0.3f*househeight,0.03f*housewidth,ratio);
     //the end of drawing the door on the second house.

     //draw the window on the door
     gl.glColor3f(1.0f,1.0f,1.0f);
     drawFilledCircle(gl,startdoor3+0.05f*housewidth,bound1+offset1+0.3f*househeight,0.03f*housewidth,ratio,20);
    //ok now the first house is done, need to draw another two fences.
     //now need to draw the bound of the circle
     gl.glColor3f(0.0f,0.0f,0.0f);
     drawHollowCircle(gl,startdoor3+0.05f*housewidth,bound1+offset1+0.3f*househeight,0.03f*housewidth,ratio);
     drawWindow(gl,startdoor3+0.45f*housewidth,bound1+offset1+(float)(0.4*househeight),(float)(0.20f*househeight),(float)(0.15f*housewidth));
     //end of drawing two windows on the door
     //now need to draw the second window here
     drawWindow(gl,startdoor3+0.50f*housewidth+0.15f*housewidth,bound1+offset1+(float)(0.4*househeight),(float)(0.20f*househeight),(float)(0.15f*housewidth));
    //end of drawing door and windor for the last house
    //now set the color back
    gl.glColor3f(1.0f,1.0f,1.0f);

    //now need to draw the last fence
    float start8=(float)(start7+housewidth-width); //since the index start from 1.
       for(int i=1;i<=2;i++)
    {
          gl.glColor3f((float)(192.0/255.0),(float)(187/255.0),(float)(126/255.0));
        if(i%2==0)
        {
        	//if i is even, then the rigfht height is less than the left height.
        	drawPolygon(gl,(float)(start8+i*width
    		),bound1+offset1,rightheight,leftheight,width);
    	drawPolyBoundary(gl,(float)(start8+i*width
    		),bound1+offset1,rightheight,leftheight,width);

        	continue;
        }
    	drawPolygon(gl,(float)(start8+i*width
    		),bound1+offset1,leftheight,rightheight,width);
    	drawPolyBoundary(gl,(float)(start8+i*width
    		),bound1+offset1,leftheight,rightheight,width);
    }
    
     float offset3=0.04f;

     //this is drawing the whole kite:
     gl.glColor3f((float)(42.0/255.0),(float)(79/255.0),(float)(227/255.0));
     drawFilledCircleCustomized(gl,0.5f,0.4f,0.1f,ratio);

    


     //now need to draw the string of the kite.
     //This is something that be done later.


     //now trying to draw the eight angles star
     gl.glColor3f((float)(248.0/255.0),(float)(249/255.0),(float)(158/255.0));
     drawEightStar(gl,0.7f,0.9f,0.01f,0.02f,ratio,8);
     drawEightStar(gl,0.6f,0.96f,0.01f,0.02f,ratio,8);
     drawEightStar(gl,0.8f,0.92f,0.01f,0.02f,ratio,8);
     gl.glColor3f((float)(136.0/255.0),(float)(137.0/255.0),(float)(19.0/255.0));
     drawEightStar(gl,0.83f,0.72f,0.01f,0.02f,ratio,8);
     gl.glColor3f((float)(116.0/255.0),(float)(110/255.0),(float)(49/255.0));
     drawEightStar(gl,0.78f,0.52f,0.01f,0.02f,ratio,8);
     //draw
     //drawStar(gl,0.8f,0.9f,0.01f,0.02f,ratio,5);
     //now need to draw the fancy moon
     gl.glColor3f(1.0f,1.0f,1.0f);
     drawMoon(gl,-0.85f,0.7f,0.1f,ratio,18);
   

	}

	private void drawStar(GL2 gl,float x, float y,float radiussmall,float radiusbig,float ratio,int lineAmount)
	{
		gl.glColor3f((float)(248.0/255.0),(float)(249/255.0),(float)(158/255.0));
		float twicePi = 2.0f * 3.1415926f;
		float rotate=56.0f/360.0f*twicePi;
		gl.glBegin(GL2.GL_TRIANGLE_FAN);
				gl.glVertex2f(x, y); // center of circle
				//this is drawing the top part of the kite
				for(int i = 0; i <= lineAmount;i++) {
					gl.glVertex2f(
				    (float)(x + (radiussmall * Math.cos(rotate+i *  twicePi / lineAmount))), 
				    (float)(y + (radiussmall* Math.sin(rotate+i * twicePi / lineAmount)*ratio))
				);
				}
			gl.glEnd();

		//now need to draw the triangle
		float rotate1=(float)(92.0f/360.0)*twicePi;
		for(int i = 0; i <= lineAmount;i++) { 
				gl.glBegin(GL2.GL_POLYGON);
				gl.glVertex2f(
				    (float)(x + (radiusbig * Math.cos(rotate1+i *  twicePi / lineAmount))), 
				    (float)(y + (radiusbig* Math.sin(rotate1+i * twicePi / lineAmount)*ratio))
				);
				gl.glVertex2f(
				    (float)(x + (radiussmall * Math.cos(rotate+i *  twicePi / lineAmount))), 
				    (float)(y + (radiussmall* Math.sin(rotate+i * twicePi / lineAmount)*ratio))
				);
				gl.glVertex2f(
				    (float)(x + (radiussmall * Math.cos(rotate+(i+1) *  twicePi / lineAmount))), 
				    (float)(y + (radiussmall* Math.sin(rotate+(i+1)* twicePi / lineAmount)*ratio))
				);

	            gl.glEnd();
			}


	}

    private void drawEightStar(GL2 gl, float x, float y, float radiussmall, float radiusbig,float ratio,int numberOfTriangle)
    {
    	//set teh color to yellow before draw it.
    	
    		float twicePi = 2.0f * 3.1415926f;
    	drawFilledCircle(gl,x,y,radiussmall,ratio,numberOfTriangle);
    	float bigstart=(float)(twicePi-twicePi/(2.0*numberOfTriangle));
        //float rotate=0.0f;//(float)(0.1f*twicePi);
        //float bigstart=0.0f;
        //gl.gl
    	float lineAmount=numberOfTriangle;
			for(int i = 0; i <= numberOfTriangle;i++) { 
				gl.glBegin(GL2.GL_POLYGON);
				gl.glVertex2f(
				    (float)(x + (radiusbig * Math.cos(i *  twicePi / lineAmount))), 
				    (float)(y + (radiusbig* Math.sin(i * twicePi / lineAmount)*ratio))
				);
				gl.glVertex2f(
				    (float)(x + (radiussmall * Math.cos(bigstart+i *  twicePi / lineAmount))), 
				    (float)(y + (radiussmall* Math.sin(bigstart+i * twicePi / lineAmount)*ratio))
				);
				gl.glVertex2f(
				    (float)(x + (radiussmall * Math.cos(bigstart+(i+1) *  twicePi / lineAmount))), 
				    (float)(y + (radiussmall* Math.sin(bigstart+(i+1)* twicePi / lineAmount)*ratio))
				);

	            gl.glEnd();
			}
    }

    //private void drawFileAngleStar



    private void drawHollowCircle(GL2 gl,float x, float y, float radius,float ratio){
		
		int lineAmount = 100; //# of triangles used to draw circle
		
		//GLfloat radius = 0.8f; //radius
		float twicePi = 2.0f * 3.1415926f;
		
		gl.glBegin(GL2.GL_LINE_LOOP);
			for(int i = 0; i <= lineAmount;i++) { 
				gl.glVertex2f(
				    (float)(x + (radius * Math.cos(i *  twicePi / lineAmount))), 
				    (float)(y + (radius* Math.sin(i * twicePi / lineAmount)*ratio))
				);
			}
	

		gl.glEnd();
    }

    //now need to draw the moon, gosh moon takes sometime to draw for sure!!!.
    private void drawMoon(GL2 gl,float x, float y,float radius, float ratio,int numberOfLines)
    {
    	
    	drawFilledCircle(gl,x,y,radius,ratio,numberOfLines);
    	float twicePi = 2.0f * 3.1415926f;
    		float[] list=new float[100];
			//list[0]=1.0f;
		//drawFilledCircle(gl,newx,newy,radius,ratio,numberOfLines);
		//gl.glColor3f((float)(81.0/255.0),(float)(82/255.0),(float)(100/255.0));
		gl.glBegin(GL2.GL_TRIANGLE_FAN);
				gl.glVertex2f(x, y); // center of circle
				//this is drawing the top part of the kite
				
				for(int i = 0; i <= numberOfLines;i++) {
					if(i>=0&&i<=5)
					{
						//add the point to the list
						list[2*i]= (float)(x + (radius * Math.cos(i *  twicePi / numberOfLines)));
						list[2*i+1]=(float)(y + (radius * Math.sin(i * twicePi / numberOfLines))*ratio);

					}

					if(i==6)
					{
						//gl.glColor3f((float)(81.0/255.0),(float)(82/255.0),(float)(100/255.0));
						gl.glColor3f(1.0f,1.0f,1.0f);
					}
					// //if(i)
					// if(i==17)
					// {
					// 	//gl.glColor3f((float)(15.0/255.0),(float)(23.0/255.0),(float)(36.0/255.0));
					// 	gl.glColor3f((float)(81.0/255.0),(float)(82/255.0),(float)(100/255.0));
					// }
					gl.glVertex2f(
				            (float)(x + (radius * Math.cos(i *  twicePi / numberOfLines))), 
				            //ok the ratio should be applied here.
					    (float)(y + (radius * Math.sin(i * twicePi / numberOfLines))*ratio)
					);
				}
			gl.glEnd();
		// gl.glEnd();
		//gl.glColor3f((float)(146.0/255.0),(float)(146.0/255.0),(float)(146.0/255.0));
			//gl.glColor3f(1.0f,1.0f,1.0f);
		gl.glColor3f(1.0f,1.0f,1.0f);
		float newx=(float)(x+radius*Math.cos(50.0/360.0*twicePi));
		float newy=(float)(y+radius*Math.sin(50.0/360.0*twicePi));
		//drawFilledCircle(gl,newx,newy,radius,ratio,numberOfLines);
		// gl.glBegin(GL2.GL_TRIANGLE_FAN);
		// 		gl.glVertex2f(newx, newy); // center of circle
		// 		//this is drawing the top part of the kite
				
				for(int i = 0; i <= numberOfLines;i++) {
					if(i>=8&&i<=14)
					{
						list[12+2*(i-8)]=(float)(newx + (radius * Math.cos(i *  twicePi / numberOfLines)));
						list[12+2*(i-8)+1]=(float)(newy + (radius * Math.sin(i * twicePi / numberOfLines))*ratio);
					}
					if(i==8)
					{
						gl.glColor3f((float)(81.0/255.0),(float)(82/255.0),(float)(100/255.0));
					}
					//if(i)
					if(i==14)
					{
						gl.glColor3f((float)(146.0/255.0),(float)(146.0/255.0),(float)(146.0/255.0));
					}
					gl.glVertex2f(
				            (float)(newx + (radius * Math.cos(i *  twicePi / numberOfLines))), 
				            //ok the ratio should be applied here.
					    (float)(newy + (radius * Math.sin(i * twicePi / numberOfLines))*ratio)
					);
				}
		    gl.glColor3f((float)(146.0/255.0),(float)(146.0/255.0),(float)(146.0/255.0));
			list[24]= (float)(x + (radius * Math.cos(16 *  twicePi / numberOfLines)));
			list[25]=  (float)(y + (radius * Math.sin(16 * twicePi / numberOfLines))*ratio);
			list[26]=(float)(x + (radius * Math.cos(17 *  twicePi / numberOfLines)));
			list[27]=(float)(y + (radius * Math.sin(17* twicePi / numberOfLines))*ratio);
		    list[28]=(float)(x + (radius * Math.cos(18 *  twicePi / numberOfLines)));
			list[29]=(float)(y + (radius * Math.sin(18* twicePi / numberOfLines))*ratio);
            gl.glBegin(GL2.GL_POLYGON);
			for(int i=1;i<=14;i++)
			{
					gl.glVertex2f(
					    list[2*i], 
					    // (float)(y + (radius* Math.sin(i * twicePi / lineAmount)*ratio))
					    list[2*i+1]
					);
			   
			}
			 gl.glEnd();
    }



    private float findDistanceTwoPoints(float x1,float y1, float x2, float y2)
    {
    	return (float)(Math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));
    }
    
    private void drawFilledCircleCustomized(GL2 gl,float x, float y, float radius,float ratio){
			int i;
			int triangleAmount = 18; //# of triangles used to draw circle
			
			//GLfloat radius = 0.8f; //radius
			float twicePi = 2.0f * 3.1415926f;
			float pi=3.1415926f;;
			gl.glBegin(GL2.GL_TRIANGLE_FAN);
				gl.glVertex2f(x, y); // center of circle
				for(i = 0; i <=9;i++) {
				    if((i>=0&&i<=3))
				    {
				    	continue;
				    } 
					gl.glVertex2f(
				            (float)(x + (radius * Math.cos(i *  twicePi / triangleAmount))), 
				            //ok the ratio should be applied here.
					    (float)(y + (radius * Math.sin(i * twicePi / triangleAmount))*ratio)
					);
				}
			gl.glEnd();
			gl.glBegin(GL2.GL_TRIANGLE_FAN);
				gl.glVertex2f(x, y); // center of circle
				for(i = 0; i <=9;i++) {
				    if((i>=0&&i<=3))
				    {
				    	continue;
				    } 
					gl.glVertex2f(
				            (float)(x + (radius * Math.cos(pi+i *  twicePi / triangleAmount))), 
				            //ok the ratio should be appliSed here.
					    (float)(y + (radius * Math.sin(pi+i * twicePi / triangleAmount))*ratio)
					);
				}
			gl.glEnd();

			//draw the boundary and the radius
			gl.glColor3f(1.0f,1.0f,1.0f);
			float lineAmount=triangleAmount;
			gl.glBegin(GL2.GL_LINE_LOOP);
			for(i = 0; i <=9;i++) { 
				 if((i>=0&&i<=3))
				    {
				    	continue;
				    } 
				gl.glVertex2f(
				    (float)(x + (radius * Math.cos(i *  twicePi / lineAmount))), 
				    (float)(y + (radius* Math.sin(i * twicePi / lineAmount)*ratio))
				);
			}
			gl.glVertex2f(x, y); 
		    gl.glEnd();
		    //draw the lower bound 
			gl.glBegin(GL2.GL_LINE_LOOP);
			for(i = 0; i <=9;i++) { 
				 if((i>=0&&i<=3))
				    {
				    	continue;
				    } 
				gl.glVertex2f(
				    (float)(x + (radius * Math.cos(pi+i *  twicePi / lineAmount))), 
				    (float)(y + (radius* Math.sin(pi+i * twicePi / lineAmount)*ratio))
				);
			}
			gl.glVertex2f(x, y); 
		    gl.glEnd();

		    //now need to draw the radius on the kite
			for(i = 0; i <=9;i++) { 
				 if((i>=0&&i<=3))
				    {
				    	continue;
				    }
				gl.glBegin(GL2.GL_LINES);
				 gl.glVertex2f(x, y);    
				gl.glVertex2f(
				    (float)(x + (radius * Math.cos(i *  twicePi / lineAmount))), 
				    (float)(y + (radius* Math.sin(i * twicePi / lineAmount)*ratio))
				);
				gl.glEnd();
			}

			for(i = 0; i <=9;i++) { 
				 if((i>=0&&i<=3))
				    {
				    	continue;
				    }
				gl.glBegin(GL2.GL_LINES);
				 gl.glVertex2f(x, y);    
				gl.glVertex2f(
				    (float)(x + (radius * Math.cos(pi+i *  twicePi / lineAmount))), 
				    (float)(y + (radius* Math.sin(pi+i * twicePi / lineAmount)*ratio))
				);
				gl.glEnd();
			}
			 
		    


    }
       private void drawFilledCircle(GL2 gl,float x, float y, float radius,float ratio, int triangleAmount){
			int i;
			float twicePi = 2.0f * 3.1415926f;
			
			gl.glBegin(GL2.GL_TRIANGLE_FAN);
				gl.glVertex2f(x, y); // center of circle
				//this is drawing the top part of the kite
				for(i = 0; i <= triangleAmount;i++) {
					gl.glVertex2f(
				            (float)(x + (radius * Math.cos(i *  twicePi / triangleAmount))), 
				            //ok the ratio should be applied here.
					    (float)(y + (radius * Math.sin(i * twicePi / triangleAmount))*ratio)
					);
				}
			gl.glEnd();
    }


    private float findYonTheLine(float x1, float y1,float x2,float y2,float x)
    {
    	return (float)(y2+(y2-y1)/(x2-x1)*(x-x2));
    }

    //just need to pass in the bottom left cornor and width of the window, then it will automatically draw a window for you
    private void drawWindow(GL2 gl, float x, float y, float height,float width )
    {
    	//draw the rectangular fr the windiw
    	gl.glColor3f(1.0f,1.0f,1.0f);  
    	drawPolygon(gl,x,y,height,height,width);
    	gl.glColor3f(0.0f,0.0f,0.0f);
    	drawPolyBoundary(gl,x,y,height,height,width);
    	//triangle
    	gl.glColor3f((float)(248.0/255.0),(float)(249/255.0),(float)(158/255.0));
    	drawTriangle(gl,x,y,width,height);
    	//then draw that two lines in the middle of the window.
          gl.glColor3f(0.0f,0.0f,0.0f);    	 

	  	  float middlex1=x;
	  	  float middley1=(float)(y+height/2.0);
	  	  float middlex2=x+width;

	  	  gl.glBegin(GL2.GL_LINES);
	  	  gl.glVertex2f(middlex1,middley1);
	  	  gl.glVertex2f(middlex2,middley1);
	  	  
	  	  gl.glEnd();

	  	  float middlex=(float)(x+width/2.0);
	  	  float middley=y;
	  	  float middley2=y+height;

	  	  gl.glBegin(GL2.GL_LINES);
	  	  gl.glVertex2f(middlex,middley);
	  	  gl.glVertex2f(middlex,middley2);
	  	  gl.glEnd();

    }
    	private void drawTriangle(GL2 gl, float f1, float f2,float width,float height)
	{
		gl.glBegin(GL2.GL_POLYGON);
		float f3=f1+width;
		float f4=f2;
		float f5=(float)(f1/2+f3/2);
		float f6=f2+height;
		gl.glVertex2f(f1,f2);
  	    gl.glVertex2f(f3,f4);
  	    gl.glVertex2f(f5,f6);
  	    gl.glEnd();
	}


    //this is in counterclock posituon, using the start point to generate the polygon,(f1,f2) is the position of the bottom left.
    //this actually draw a rectangle instead of drawing whatever number of the stuff.
    	private void drawPolyBoundary(GL2 gl,float f1, float f2, float leftheight, float rightheight, float width)
	{
		  //float thickness=200.0f;
		  gl.glBegin(GL2.GL_LINES);
		  //gl.glLineWidth(thickness);
		  float f3=f1+width;
		  float f4=f2;
		  float f5=f3;
		  float f6=f2+rightheight;
		  float f7=f1;
		  float f8=f2+leftheight;
	  	  gl.glVertex2f(f1,f2);
	  	  gl.glVertex2f(f3,f4);
	  	  gl.glColor3f(0.0f,0.0f,0.0f);
	  	  gl.glEnd();

	  	  gl.glBegin(GL2.GL_LINES);
	  	  gl.glVertex2f(f3,f4);
	  	  gl.glVertex2f(f5,f6);
	  	  //gl.glColor3f(0.0f,0.0f,0.0f);
	  	  gl.glEnd();

	  	  gl.glBegin(GL2.GL_LINES);
	  	  gl.glVertex2f(f5,f6);
	  	  gl.glVertex2f(f7,f8);
	  	  //gl.glColor3f(0.0f,0.0f,0.0f);
	  	  gl.glEnd();

	  	  gl.glBegin(GL2.GL_LINES);
	  	  gl.glVertex2f(f7,f8);
	  	  gl.glVertex2f(f1,f2);
	  	  //gl.glColor3f(0.0f,0.0f,0.0f);
	  	  gl.glEnd();
	}
	//this is draw rectangle which is 90 degree
	private void drawPolygon(GL2 gl,float f1, float f2, float leftheight, float rightheight, float width)
	{
		gl.glBegin(GL2.GL_POLYGON);
		float f3=f1+width;
		float f4=f2;
		float f5=f3;
		float f6=f2+rightheight;
		float f7=f1;
		float f8=f2+leftheight;
  	    gl.glVertex2f(f1,f2);
  	    gl.glVertex2f(f3,f4);
  	    gl.glVertex2f(f5,f6);
  	    gl.glVertex2f(f7,f8);
  	    gl.glEnd();
		  	  
	}
	//need to draw the vertical two polygons
	private void draw2Polygon(GL2 gl,float f1, float f2, float f3, float f4, float f5, float f6)
	{
		gl.glBegin(GL2.GL_POLYGON);
		//gl.glColor3f(0.0f,0.0f,0.0f);
		float f7=(float)(f5-(f3-f1));
		float f8=f6;
		System.out.println("hey"+f7);
		System.out.println("ha"+f8);
  	    gl.glVertex2f(f1,f2);
  	    gl.glVertex2f(f3,f4);
  	    gl.glVertex2f(f5,f6);
  	    gl.glVertex2f(f7,f8);
  	    gl.glEnd();

  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(f1,f2);
  	    gl.glVertex2f(f3,f4);
  	    gl.glEnd();
  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(f3,f4);
  	    gl.glVertex2f(f5,f6);
  	    gl.glEnd();
  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(f5,f6);
  	    gl.glVertex2f(f7,f8);
  	    gl.glEnd();
  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(f7,f8);
  	    gl.glVertex2f(f1,f2);
  	    gl.glEnd();

  	    float p1x=(float)(f1+f7)*0.5f;
  	    float p1y=(float)(f2+f8)*0.5f;
  	    float p2x=(float)(f3+f5)*0.5f;
  	    float p2y=(float)(f4+f6)*0.5f;
  	
  	    //need to draw the lines
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(p1x,p1y);
  	    gl.glVertex2f(p2x,p2y);
  	    gl.glEnd();

	}
    //need 3 points start from bottom letf to the top right
	private void draw3Polygon(GL2 gl, float f1, float f2, float f3,float f4, float f5,float f6,float grassdiff, float grassheightstart, float grasswidth, float grassheight)
	{
		gl.glBegin(GL2.GL_POLYGON);
		//gl.glColor3f(0.0f,0.0f,0.0f);
		float f7=(float)(f5-(f3-f1));
		float f8=f6;
		//System.out.println("hey"+f7);
		//System.out.println("ha"+f8);
  	    gl.glVertex2f(f1,f2);
  	    gl.glVertex2f(f3,f4);
  	    gl.glVertex2f(f5,f6);
  	    gl.glVertex2f(f7,f8);
  	    gl.glEnd();
  	    //draw boundary of the polygons
  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(f1,f2);
  	    gl.glVertex2f(f3,f4);
  	    gl.glEnd();
  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(f3,f4);
  	    gl.glVertex2f(f5,f6);
  	    gl.glEnd();
  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(f5,f6);
  	    gl.glVertex2f(f7,f8);
  	    gl.glEnd();
  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(f7,f8);
  	    gl.glVertex2f(f1,f2);
  	    gl.glEnd();
  	    //draw two lines in the mid
  	    float p1x=(float)(f1+0.3333*(f3-f1));
  	    float p1y=f2;
  	    float p2x=(float)(f5-0.6666*(f3-f1));
  	    float p2y=f6;
  	    float p3x=(float)(f1+0.6666*(f3-f1));
  	    float p3y=f2;
  	    float p4x=(float)(f5-0.3333*(f3-f1));
  	    float p4y=f6;
  	    //need to draw the lines
  	       gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(p1x,p1y);
  	    gl.glVertex2f(p2x,p2y);
  	    gl.glEnd();
  	       gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(p3x,p3y);
  	    gl.glVertex2f(p4x,p4y);
  	    gl.glEnd();

  	    //now need to draw the two polygons adjacent to it
  	    //let the midpoint be the start point:
      //gl.glColor3f((float)(189.0/255.0),(float)(190.0/255.0),(float)(149.0/255.0)); 
      gl.glColor3f((float)(189.0/255.0),(float)(190.0/255.0),(float)(149.0/255.0));  
      float p11=(float)(f3+f5)*0.5f;
      float p12=(float)(f4+f6)*0.5f;

      //draw3Polygon(gl,grassstart,grassheightstart,grassstart+grasswidth,grassheightstart,grassstart+grasswidth+grassdiff,grassheightstart+grassheight);
      float p13=p11+0.333f*grasswidth;
      float p14=p12;
      float p15=p11+0.333f*grasswidth+grassdiff;
      float p16=p12+grassheight;
      float p17=(float)(p15-(p13-p11));
      float p18=p16;
      gl.glBegin(GL2.GL_POLYGON);
  	    gl.glVertex2f(p11,p12);
  	    gl.glVertex2f(p13,p14);
  	    gl.glVertex2f(p15,p16);
  	    gl.glVertex2f(p17,p18);
  	    gl.glEnd();
  	  //now need to draw the boudary on here
  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(p11,p12);
  	    gl.glVertex2f(p13,p14);
  	    gl.glEnd();
  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(p13,p14);
  	    gl.glVertex2f(p15,p16);
  	    gl.glEnd();
  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(p15,p16);
  	    gl.glVertex2f(p17,p18);
  	    gl.glEnd();
  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(p17,p18);
  	    gl.glVertex2f(p11,p12);
  	    gl.glEnd();
  	    //end of drawing the boundary lines
  	    //now need to draw the bottom one
  	    float p171=p11-grassdiff;
      float p181=p12-grassheight;
      float p151=p13-grassdiff;
      float p161=p181;
      gl.glColor3f((float)(189.0/255.0),(float)(190.0/255.0),(float)(149.0/255.0)); 
        gl.glBegin(GL2.GL_POLYGON);
  	    gl.glVertex2f(p11,p12);
  	    gl.glVertex2f(p13,p14);
  	    gl.glVertex2f(p151,p161);
  	    gl.glVertex2f(p171,p181);
  	    gl.glEnd();
  	    //ok now need the boundayr

  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(p13,p14);
  	    gl.glVertex2f(p151,p161);
  	    gl.glEnd();
  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(p151,p161);
  	    gl.glVertex2f(p171,p181);
  	    gl.glEnd();
  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(p171,p181);
  	    gl.glVertex2f(p11,p12);
  	    gl.glEnd();

  	    //now need to draw the adjacent individaul one
  	    float q11=f3+0.333f*grasswidth;
  	    float q12=f4;
  	    float q13=q11+0.333f*grasswidth;
        float q14=q12;
        float q15=q11+0.333f*grasswidth+grassdiff;
        float q16=q12+grassheight;
        float q17=(float)(q15-(q13-q11));
        float q18=q16;
  	    gl.glColor3f((float)(189.0/255.0),(float)(190.0/255.0),(float)(149.0/255.0)); 
        gl.glBegin(GL2.GL_POLYGON);
  	    gl.glVertex2f(q11,q12);
  	    gl.glVertex2f(q13,q14);
  	    gl.glVertex2f(q15,q16);
  	    gl.glVertex2f(q17,q18);
  	    gl.glEnd();
  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(q11,q12);
  	    gl.glVertex2f(q13,q14);
  	    gl.glEnd();
  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(q15,q16);
  	    gl.glVertex2f(q17,q18);
  	    gl.glEnd();
  	  
  	    //drawHorizontalTransmissionPolygon(gl,q11,q12,q13,q14,q15,q16,q17,q18,grasswidth);

  	    //now need to transmit thsi to the right by the grasswidth
  	  drawHorizontalTransmissionPolygon(gl,q11,q12,q13,q14,q15,q16,q17,q18,0.6666f*grasswidth);
      //drawing the last vertical one
      //just need to reset the start point for this need more extraction of the method of using instead of copy paste everywhere!!!!
      gl.glColor3f((float)(189.0/255.0),(float)(190.0/255.0),(float)(149.0/255.0)); 
      p11=p11+0.666f*grasswidth;
      p12=p12;
  	  p13=p11+0.333f*grasswidth;
      p14=p12;
      p15=p11+0.333f*grasswidth+grassdiff;
      p16=p12+grassheight;
      p17=(float)(p15-(p13-p11));
      p18=p16;
      gl.glBegin(GL2.GL_POLYGON);
  	    gl.glVertex2f(p11,p12);
  	    gl.glVertex2f(p13,p14);
  	    gl.glVertex2f(p15,p16);
  	    gl.glVertex2f(p17,p18);
  	    gl.glEnd();
  	  //now need to draw the boudary on here
  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(p11,p12);
  	    gl.glVertex2f(p13,p14);
  	    gl.glEnd();
  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(p13,p14);
  	    gl.glVertex2f(p15,p16);
  	    gl.glEnd();
  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(p15,p16);
  	    gl.glVertex2f(p17,p18);
  	    gl.glEnd();
  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(p17,p18);
  	    gl.glVertex2f(p11,p12);
  	    gl.glEnd();
  	    //end of drawing the boundary lines
  	    //now need to draw the bottom one
	     p171=p11-grassdiff;
        p181=p12-grassheight;
        p151=p13-grassdiff;
        p161=p181;
        gl.glColor3f((float)(189.0/255.0),(float)(190.0/255.0),(float)(149.0/255.0)); 
        gl.glBegin(GL2.GL_POLYGON);
  	    gl.glVertex2f(p11,p12);
  	    gl.glVertex2f(p13,p14);
  	    gl.glVertex2f(p151,p161);
  	    gl.glVertex2f(p171,p181);
  	    gl.glEnd();
  	    //ok now need the boundayr

  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(p13,p14);
  	    gl.glVertex2f(p151,p161);
  	    gl.glEnd();
  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(p151,p161);
  	    gl.glVertex2f(p171,p181);
  	    gl.glEnd();
  	    gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(p171,p181);
  	    gl.glVertex2f(p11,p12);
  	    gl.glEnd();
  	   //end of drawing the last vertical one

	}

	private void drawHorizontalTransmissionPolygon(GL2 gl, float f1, float f2, float f3, float f4, float f5, float f6, float f7, float f8, float tran)
	{
		float f11=f1+tran;
		float f12=f2;
		float f13=f3+tran;
		float f14=f4;
		float f15=f5+tran;
		float f16=f6;
		float f17=f7+tran;
		float f18=f8;
		gl.glColor3f((float)(189.0/255.0),(float)(190.0/255.0),(float)(149.0/255.0)); 
        gl.glBegin(GL2.GL_POLYGON);
  	    gl.glVertex2f(f11,f12);
  	    gl.glVertex2f(f13,f14);
  	    gl.glVertex2f(f15,f16);
  	    gl.glVertex2f(f17,f18);
  	    gl.glEnd();
  	     gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(f11,f12);
  	    gl.glVertex2f(f13,f14);
  	    gl.glEnd();
  	     gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(f13,f14);
  	    gl.glVertex2f(f15,f16);
  	    gl.glEnd();
  	     gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(f15,f16);
  	    gl.glVertex2f(f17,f18);
  	    gl.glEnd();
  	     gl.glColor3f(1.0f,1.0f,1.0f);
  	    gl.glBegin(GL2.GL_LINES);
  	    gl.glVertex2f(f17,f18);
  	    gl.glVertex2f(f11,f12);
  	    gl.glEnd();
	}

	//draw a "regular" triangle with the point on the bottom left and the length of the bvottom of the triangle and the height of the triangle.


	// This example on this page is long but helpful:
	// http://jogamp.org/jogl-demos/src/demos/j2d/FlyingText.java
	// Warning! Text is drawn in pixel coordinates, not projection coordinates.
	private void drawSomeText(GLAutoDrawable drawable)
	{
		// renderer.beginRendering(drawable.getWidth(), drawable.getHeight());
		// System.out.println("width: height:"+drawable.getWidth()+" "+drawable.getHeight());
		// renderer.setColor(1.0f, 1.0f, 0, 1.0f);
		// renderer.draw("This is a point", w/2 + 8, h/2 - 5);
		// renderer.endRendering();
	}
}

//******************************************************************************
